<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manual Harmony Analyzer (Pro)</title>
    <style>
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 { color: #00ff88; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; }
        .subtitle { font-size: 0.9em; opacity: 0.7; margin-bottom: 20px; }

        /* CONTROL PANEL */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            background: #1e1e1e;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        button, select, input::file-selector-button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 15px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
        }
        button:hover { background: #444; }
        button.active { background: #00ff88; color: black; border-color: #00ff88; }
        
        /* WORKSPACE */
        #workspace {
            position: relative;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            display: none; /* Hidden until image loaded */
        }

        canvas { display: block; max-width: 90vw; max-height: 70vh; }

        /* INSTRUCTION BOX */
        #guide-box {
            margin-top: 15px;
            background: #2a2a2a;
            border-left: 4px solid #00ff88;
            padding: 15px;
            width: 90%;
            max-width: 600px;
            text-align: center;
            font-size: 1.1em;
        }
        #current-step { color: #00ff88; font-weight: bold; }

        /* ZOOM LENS */
        #magnifier {
            position: absolute;
            border: 2px solid #00ff88;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            pointer-events: none; /* Click through it */
            display: none;
            background-repeat: no-repeat;
            background-color: #000;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0,255,136,0.5);
        }

        /* RESULTS */
        #report {
            margin-top: 30px;
            width: 90%;
            max-width: 800px;
            display: none;
        }
        .metric-card {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .metric-name { font-weight: bold; }
        .tier-s { color: #ffd700; font-weight: bold; }
        .tier-a { color: #00ff88; font-weight: bold; }
        .tier-b { color: #00ccff; }
        .tier-f { color: #ff4444; }

    </style>
</head>
<body>

    <h1>Harmony Analyzer <span style="font-size:0.5em; vertical-align:top;">PRO</span></h1>
    <div class="subtitle">Manual Landmark Edition (Precision Tool)</div>

    <div class="controls">
        <input type="file" id="imageUpload" accept="image/*">
        <select id="profileType">
            <option value="front">Front Profile</option>
            <option value="side">Side Profile</option>
        </select>
        <button onclick="reset()" style="background:#552222;">Reset</button>
    </div>

    <div id="guide-box">
        Step <span id="step-count">0</span>: <span id="current-step">Upload an image to begin</span>
    </div>

    <div id="workspace">
        <canvas id="mainCanvas"></canvas>
        <div id="magnifier"></div>
    </div>

    <div id="report">
        <h3 style="border-bottom: 1px dashed #555; padding-bottom:10px;">// ANALYSIS REPORT</h3>
        <div id="metrics-container"></div>
    </div>

    <script>
        // CONFIGURATION
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const magnifier = document.getElementById('magnifier');
        const workspace = document.getElementById('workspace');
        
        let img = new Image();
        let scale = 1;
        let points = [];
        let currentMode = "front";
        let stepIndex = 0;

        // DEFINING THE LANDMARKS
        const LANDMARKS = {
            front: [
                { id: "hairline", name: "Top of Forehead (Hairline)" },
                { id: "glabella", name: "Between Eyebrows (Glabella)" },
                { id: "subnasale", name: "Bottom of Nose (Base)" },
                { id: "menton", name: "Bottom of Chin" },
                { id: "l_ex", name: "Left Eye Outer Corner" },
                { id: "l_en", name: "Left Eye Inner Corner" },
                { id: "r_en", name: "Right Eye Inner Corner" },
                { id: "r_ex", name: "Right Eye Outer Corner" },
                { id: "l_zygo", name: "Left Cheekbone (Widest Point)" },
                { id: "r_zygo", name: "Right Cheekbone (Widest Point)" }
            ],
            side: [
                { id: "glabella", name: "Brow Ridge (Most Forward Point)" },
                { id: "nasion", name: "Nose Bridge (Deepest Dip)" },
                { id: "pronasale", name: "Nose Tip" },
                { id: "subnasale", name: "Nose Base (Connection to Lip)" },
                { id: "ls", name: "Upper Lip (Most Forward)" },
                { id: "li", name: "Lower Lip (Most Forward)" },
                { id: "pogonion", name: "Chin Tip (Most Forward)" },
                { id: "menton", name: "Chin Bottom (Lowest Point)" },
                { id: "gonion", name: "Jaw Corner (The Angle)" },
                { id: "tragion", name: "Ear Canal (Tragus)" }
            ]
        };

        // EVENT LISTENERS
        document.getElementById('imageUpload').addEventListener('change', handleUpload);
        document.getElementById('profileType').addEventListener('change', (e) => {
            currentMode = e.target.value;
            reset();
        });
        
        canvas.addEventListener('mousemove', handleMagnifier);
        canvas.addEventListener('mouseout', () => magnifier.style.display = 'none');
        canvas.addEventListener('click', handlePointClick);

        function handleUpload(e) {
            const file = e.target.files[0];
            if(!file) return;
            const url = URL.createObjectURL(file);
            img.onload = () => {
                // Determine scale to fit screen
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.7;
                const ratio = Math.min(maxWidth / img.width, maxHeight / img.height);
                
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;
                scale = ratio;
                
                reset();
                draw();
                workspace.style.display = 'block';
                document.getElementById('report').style.display = 'none';
            };
            img.src = url;
        }

        function reset() {
            points = [];
            stepIndex = 0;
            updateGuide();
            draw();
            document.getElementById('report').style.display = 'none';
        }

        function handleMagnifier(e) {
            if(!img.src) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            magnifier.style.display = 'block';
            magnifier.style.left = (x - 60) + 'px'; // Center the 120px div
            magnifier.style.top = (y - 60) + 'px';

            // Calculate zoom background position
            // We want the background to show the image corresponding to mouse pos
            // Image is drawn at 'scale'. 
            // Zoom level: 2x or 3x
            const zoom = 3; 
            
            // Map canvas coord back to image coord
            const imgX = x / scale;
            const imgY = y / scale;

            magnifier.style.backgroundImage = `url('${img.src}')`;
            magnifier.style.backgroundSize = `${img.width * scale * zoom}px ${img.height * scale * zoom}px`;
            
            // Offset logic is tricky. 
            // We need to shift the background so that (imgX, imgY) is in the center of the magnifier
            const bgPosX = -(imgX * scale * zoom - 60);
            const bgPosY = -(imgY * scale * zoom - 60);
            
            magnifier.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
        }

        function handlePointClick(e) {
            if(!img.src) return;
            const guide = LANDMARKS[currentMode];
            if(stepIndex >= guide.length) return; // Done

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            points.push({ x: x, y: y, label: guide[stepIndex].id });
            stepIndex++;
            
            draw();
            updateGuide();

            if(stepIndex >= guide.length) {
                calculateResults();
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw Image
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // Draw Overlay
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,canvas.width, canvas.height); // Dim background to make points pop
            
            // Draw Points
            points.forEach((p, index) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#00ff88';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.stroke();
                
                // Draw Label
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText(index + 1, p.x + 8, p.y + 4);
            });
            
            // Draw current active line connection preview (optional)
        }

        function updateGuide() {
            const guide = LANDMARKS[currentMode];
            const box = document.getElementById('guide-box');
            const stepSpan = document.getElementById('step-count');
            const txtSpan = document.getElementById('current-step');

            if(stepIndex < guide.length) {
                stepSpan.innerText = stepIndex + 1;
                txtSpan.innerText = "Click: " + guide[stepIndex].name;
                box.style.borderLeftColor = "#00ff88";
            } else {
                stepSpan.innerText = "Done";
                txtSpan.innerText = "Analysis Generated Below";
                box.style.borderLeftColor = "#ffd700";
            }
        }

        // --- MATH & ANALYSIS ---
        function getPt(id) {
            return points.find(p => p.label === id);
        }

        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function angle(A, B, C) {
            // Angle at B
            const AB = dist(A, B);
            const BC = dist(B, C);
            const AC = dist(A, C);
            return Math.acos((AB*AB + BC*BC - AC*AC) / (2*AB*BC)) * (180/Math.PI);
        }

        function getTier(val, sRange, aRange) {
            // Helper to determine tier
            if (val >= sRange[0] && val <= sRange[1]) return `<span class="tier-s">TIER S (Ideal)</span>`;
            if (val >= aRange[0] && val <= aRange[1]) return `<span class="tier-a">TIER A</span>`;
            return `<span class="tier-b">TIER B/C</span>`;
        }

        function calculateResults() {
            const container = document.getElementById('metrics-container');
            let html = "";

            if(currentMode === "front") {
                const l_ex = getPt("l_ex"), l_en = getPt("l_en");
                const r_ex = getPt("r_ex"), r_en = getPt("r_en");
                const hairline = getPt("hairline"), glabella = getPt("glabella");
                const subnasale = getPt("subnasale"), menton = getPt("menton");
                const l_zygo = getPt("l_zygo"), r_zygo = getPt("r_zygo");

                // 1. Canthal Tilt
                // Avg of both eyes
                const tiltL = (Math.atan2(l_ex.y - l_en.y, l_ex.x - l_en.x) * 180 / Math.PI) * -1;
                const tiltR = (Math.atan2(r_ex.y - r_en.y, r_ex.x - r_en.x) * 180 / Math.PI) * -1;
                const avgTilt = (tiltL + tiltR) / 2;
                html += createCard("Canthal Tilt", `${avgTilt.toFixed(1)}°`, getTier(avgTilt, [4, 8], [0, 12]));

                // 2. Facial Thirds
                const upper = dist(hairline, glabella);
                const mid = dist(glabella, subnasale);
                const lower = dist(subnasale, menton);
                const total = upper + mid + lower;
                
                const upP = (upper/total*100).toFixed(1);
                const midP = (mid/total*100).toFixed(1);
                const lowP = (lower/total*100).toFixed(1);

                // Ideal is 33-33-33 roughly
                let thirdsTier = "TIER B";
                if(Math.abs(33.3 - midP) < 2 && Math.abs(33.3 - lowP) < 2) thirdsTier = `<span class="tier-s">TIER S (Perfect Balance)</span>`;
                else if(Math.abs(33.3 - midP) < 4) thirdsTier = `<span class="tier-a">TIER A</span>`;
                else thirdsTier = `<span class="tier-b">TIER B</span>`;

                html += createCard("Facial Thirds", `Upper: ${upP}% | Mid: ${midP}% | Lower: ${lowP}%`, thirdsTier);

                // 3. Eye Spacing Ratio (ESR)
                const innerDist = dist(l_en, r_en);
                const faceWidth = dist(l_zygo, r_zygo);
                const esr = (innerDist / faceWidth) * 100;
                html += createCard("Eye Separation Ratio", `${esr.toFixed(1)}%`, getTier(esr, [45, 47], [42, 50]));

                // 4. FWHR (Facial Width to Height)
                // Approx height: Nasion to Menton (using glabella here as approx top of midface)
                const faceHeight = dist(glabella, menton); 
                const fwhr = faceWidth / faceHeight;
                html += createCard("Midface FWHR", `${fwhr.toFixed(2)}`, getTier(fwhr, [1.8, 2.0], [1.7, 2.1]));

            } else {
                // SIDE PROFILE
                const gonion = getPt("gonion"), tragion = getPt("tragion"), menton = getPt("menton");
                const glabella = getPt("glabella"), pogonion = getPt("pogonion");
                const nasion = getPt("nasion");

                // 1. Gonial Angle
                const gAngle = angle(tragion, gonion, menton);
                html += createCard("Gonial Angle", `${gAngle.toFixed(1)}°`, getTier(gAngle, [118, 128], [110, 135]));

                // 2. Ramus/Mandible Ratio
                const ramus = dist(tragion, gonion);
                const mandible = dist(gonion, menton);
                const ratio = ramus / mandible;
                html += createCard("Ramus/Mandible Ratio", `${ratio.toFixed(2)}`, getTier(ratio, [0.65, 0.85], [0.55, 0.95]));

                // 3. Facial Convexity (Glabella - Subnasale - Pogonion) -> Roughly
                // We'll use Glabella - Nasion - Pogonion for general projection check
                const convAngle = angle(glabella, nasion, pogonion);
                html += createCard("Facial Convexity (Est)", `${convAngle.toFixed(1)}°`, getTier(convAngle, [165, 175], [160, 180]));
            }

            container.innerHTML = html;
            document.getElementById('report').style.display = 'block';
        }

        function createCard(title, value, tier) {
            return `
            <div class="metric-card">
                <div>
                    <div class="metric-name">${title}</div>
                    <div style="font-size:0.9em; color:#888;">Measured Value: ${value}</div>
                </div>
                <div>${tier}</div>
            </div>`;
        }
    </script>
</body>
</html>
